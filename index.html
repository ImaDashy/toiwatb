<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, maximum-scale=5.0">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Literata:wght@400;700&display=swap">
    <title>The Ocean Is Wettest At The Bottom</title>
    <!-- Favicon -->
    <link rel="icon" href="/favicon.ico" sizes="any">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="manifest" href="/site.webmanifest">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Georgia', serif;
        }
        
        body {
            background-color: #f4f0e8;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }
        
        /* E-Reader Container */
        .ereader {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background-color: #f4f0e8;
            color: #333;
            position: relative;
        }
        
        /* Reading Area */
        .reading-area {
            flex: 1;
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: relative;
        }
        
        /* Page Container */
        .page-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
        }
        
        /* Individual Page */
.page {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    padding: 30px; /* Smaller default padding */
    background-color: #f4f0e8;
    overflow: auto;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
            transform: translateX(100%);
        }

        /* Adjust padding for different screen sizes */
@media (max-width: 375px) {
    .page {
        padding: 15px;
    }
}

@media (min-width: 376px) and (max-width: 480px) {
    .page {
        padding: 20px;
    }
}

@media (min-width: 481px) and (max-width: 768px) {
    .page {
        padding: 25px;
    }
}
        
        .page.active {
            transform: translateX(0);
            z-index: 2;
        }
        
        .page.previous {
            transform: translateX(-100%);
            z-index: 1;
        }
        
        .page.next {
            transform: translateX(100%);
            z-index: 1;
        }
        
        /* Page Content */
        .page-content {
            flex: 1;
            overflow: hidden;
            line-height: 1.7;
            font-size: 18px;
        }
        
        /* Cover page with full image */
        .cover-image-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        
        .full-cover-image {
            width: 100%;
            height: 100%;
            object-fit: cover; /* This ensures the image covers the entire container */
        }
        
        .cover-text-overlay {
            position: absolute;
            bottom: 20%;
            left: 0;
            width: 100%;
            text-align: center;
            color: white; /* Text color that stands out on your cover */
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); /* Text shadow for better visibility */
            padding: 20px;
        }
        
        .page-hint {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            font-style: italic;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
        }
        
        .cover-page {
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .cover-page h1 {
            font-size: 36px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .cover-page h2 {
            font-size: 24px;
            margin-bottom: 40px;
            text-align: center;
            font-weight: normal;
        }
        
        /* TOC Page */
        .toc-page h1 {
            font-size: 28px;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .toc-list {
            list-style-type: none;
        }
        
        .toc-list li {
            margin-bottom: 15px;
            font-size: 18px;
            cursor: pointer;
        }
        
        .toc-list .chapter-link:hover {
            text-decoration: underline;
        }
        
        .new-badge {
            background-color: #d35400;
            color: white;
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 8px;
            vertical-align: middle;
        }
        
        /* Chapter Page */
        .chapter-page h2 {
            font-size: 24px;
            margin-bottom: 30px;
            text-align: center;
        }
        
        /* Footnotes */
        .footnotes {
            border-top: 1px solid #ccc;
            margin-top: 20px;
            padding-top: 20px;
            font-size: 14px;
            position: relative;
            z-index: 50; /* Higher z-index to ensure clickability */
        }
        
        .footnote-ref {
            vertical-align: super;
            font-size: smaller;
            color: #0066cc;
            cursor: pointer;
            text-decoration: none;
            position: relative;
            z-index: 25; /* Higher z-index to ensure clickability */
        }
        
        .footnote-item {
            position: relative;
            z-index: 50;
            margin-bottom: 10px;
        }
        
        /* Footnote highlight */
        .footnote-highlight {
            background-color: rgba(24, 144, 255, 0.2);
            transition: background-color 0.5s ease;
        }
        
        /* Navigation Controls */
        .page-nav-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 10;
            opacity: 0.7;
        }
        
        .page-nav-controls:hover {
            opacity: 1;
        }
        
        .page-nav-button {
            background-color: #333;
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .page-nav-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .page-nav-button:hover:not(:disabled) {
            background-color: #555;
        }
        
        /* Touch navigation areas */
        .touch-nav-area {
            position: absolute;
            top: 0;
            height: 100%;
            width: 25%;
            z-index: 5;
            display: none; /* Hidden by default, shown on mobile */
        }
        
        .touch-nav-left {
            left: 0;
        }
        
        .touch-nav-right {
            right: 0;
        }

        /* Optional: add visual indicator for tap areas that's only visible when touched */
        .touch-nav-area:active {
            background-color: rgba(0, 0, 0, 0.05); /* Subtle visual feedback */
        }
        
        /* Menu Button */
        .menu-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: #333;
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 16px;
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Menu Panel */
        .panel {
            position: fixed;
            top: 0;
            right: -100%;
            width: 90%;
            max-width: 400px;
            height: 100%;
            background-color: white;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            overflow-y: auto;
            transition: right 0.3s ease;
            padding: 20px;
        }
        
        .panel.active {
            right: 0;
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        
        .panel-header h2 {
            margin: 0;
        }
        
        .close-panel-button {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
        }
        
        /* Menu Panel */
        .menu-panel {
            padding: 20px;
        }
        
        .menu-list {
            list-style-type: none;
            margin-bottom: 20px;
        }
        
        .menu-item {
            padding: 15px 10px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            font-size: 18px;
        }
        
        .menu-item:hover {
            background-color: #f5f5f5;
        }
        
        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 3000;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #0066cc;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        .loading-text {
            margin-top: 20px;
            font-size: 16px;
            color: #fff;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Dedication page styles */
        .dedication-page {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .dedication-content {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 25% 10% 25% 10%;
            font-style: italic;
            color: #333;
        }
        
        .dedication-top {
            text-align: center;
            font-size: 20px;
            margin-bottom: auto;
        }
        
        .dedication-bottom {
            text-align: center;
            font-size: 20px;
            margin-top: auto;
        }
        
        /* Mobile Optimizations */
        @media (max-width: 768px) {
            .page {
                padding: 20px;
            }
            
            .page-content {
                font-size: 16px;
                line-height: 1.6;
            }
            
            .cover-page h1 {
                font-size: 28px;
            }
            
            .cover-page h2 {
                font-size: 20px;
            }
            
            .chapter-page h2 {
                font-size: 20px;
                margin-bottom: 20px;
            }
            
            .panel {
                width: 100%;
                max-width: none;
            }
            
            /* Hide navigation buttons on mobile */
            .page-nav-controls {
                display: none;
            }

            .menu-button {
                display: none;
            }
            
            /* Show touch navigation areas on mobile */
            .touch-nav-area {
                display: block;
            }
        }

        /* Add font size controls */
        .font-size-control {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 15px 0;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 5px;
        }
        
        .font-size-control button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #1890ff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 10px;
        }
        
        .font-size-control .font-size-label {
            font-size: 16px;
            margin: 0 10px;
        }
        
    /* Tap Indicator Styles */
    .tap-indicator {
        position: absolute;
        right: 10%; /* Position on the right side */
        top: 50%;
        transform: translateY(-50%);
        width: 50px;
        height: 50px;
        z-index: 50;
        opacity: 0;
        pointer-events: none; /* Make sure it doesn't interfere with taps */
        animation: fadeInOut 5s ease-in-out 1s forwards;
    }

    .tap-circle {
        position: absolute;
        border: 2px solid rgba(255, 255, 255, 0.7);
        border-radius: 50%;
        width: 50px;
        height: 50px;
        top: 0;
        left: 0;
        opacity: 0;
    }

    .tap-circle-1 {
        animation: ripple 3s linear infinite;
        animation-delay: 0s;
    }

    .tap-circle-2 {
        animation: ripple 3s linear infinite;
        animation-delay: 0.75s;
    }

    .tap-circle-3 {
        animation: ripple 3s linear infinite;
        animation-delay: 1.5s;
    }

    .tap-center {
        position: absolute;
        width: 15px;
        height: 15px;
        background-color: rgba(255, 255, 255, 0.9);
        border-radius: 50%;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }

    .tap-arrow {
        position: absolute;
        right: 35%;
        top: 50%;
        transform: translateY(-50%);
        width: 30px;
        height: 30px;
        opacity: 0;
        animation: arrowPulse 3s ease-in-out infinite 1.5s;
    }

    .tap-arrow:before {
        content: '';
        position: absolute;
        width: 100%;
        height: 100%;
        border-top: 3px solid rgba(255, 255, 255, 0.9);
        border-right: 3px solid rgba(255, 255, 255, 0.9);
        transform: rotate(45deg);
    }

    @keyframes ripple {
        0% {
            transform: scale(0.2);
            opacity: 0;
        }
        20% {
            opacity: 0.6;
        }
        100% {
            transform: scale(2);
            opacity: 0;
        }
    }

    @keyframes fadeInOut {
        0% {
            opacity: 0;
        }
        10% {
            opacity: 1;
        }
        90% {
            opacity: 1;
        }
        100% {
            opacity: 0;
        }
    }

    @keyframes arrowPulse {
        0% {
            opacity: 0;
            transform: translateY(-50%) translateX(-10px);
        }
        50% {
            opacity: 0.9;
            transform: translateY(-50%) translateX(0px);
        }
        100% {
            opacity: 0;
            transform: translateY(-50%) translateX(10px);
        }
    }



     /* Menu Indicator Styles */
.menu-indicator {
    position: absolute;
    top: 2%; /* Moved even closer to the top edge */
    left: 50%;
    transform: translateX(-50%);
    width: 60px;
    height: 60px;
    z-index: 50;
    opacity: 0;
    pointer-events: none; /* Make sure it doesn't interfere with taps */
    animation: menuFadeInOut 5s ease-in-out 1s forwards;
    text-align: center;
}

.menu-text {
    position: absolute;
    width: 100%;
    text-align: center;
    top: -45%; /* Moved above the circles */
    left: 0;
    color: rgba(0, 0, 0, 0.8);
    font-size: 14px;
    font-weight: 500;
    letter-spacing: 2px;
    text-transform: uppercase;
    opacity: 0;
    animation: textPulse 3s ease-in-out infinite 0.5s;
}

.menu-circle {
    position: absolute;
    border: 2px solid rgba(0, 0, 0, 0.6);
    border-radius: 50%;
    width: 60px;
    height: 60px;
    top: 0;
    left: 0;
    opacity: 0;
}

.menu-circle-1 {
    animation: menuRipple 3s linear infinite;
    animation-delay: 0s;
}

.menu-circle-2 {
    animation: menuRipple 3s linear infinite;
    animation-delay: 0.75s;
}

.menu-circle-3 {
    animation: menuRipple 3s linear infinite;
    animation-delay: 1.5s;
}

.menu-center {
    position: absolute;
    width: 20px;
    height: 20px;
    background-color: rgba(0, 0, 0, 0.7);
    border-radius: 50%;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    animation: pulse 2s ease-in-out infinite;
}

@keyframes menuRipple {
    0% {
        transform: scale(0.3);
        opacity: 0;
    }
    20% {
        opacity: 0.5;
    }
    100% {
        transform: scale(1.5);
        opacity: 0;
    }
}

@keyframes menuFadeInOut {
    0% {
        opacity: 0;
    }
    10% {
        opacity: 1;
    }
    90% {
        opacity: 1;
    }
    100% {
        opacity: 0;
    }
}

@keyframes textPulse {
    0% {
        opacity: 0.3;
    }
    50% {
        opacity: 1;
    }
    100% {
        opacity: 0.3;
    }
}

@keyframes pulse {
    0% {
        transform: translate(-50%, -50%) scale(0.8);
        opacity: 0.7;
    }
    50% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
    }
    100% {
        transform: translate(-50%, -50%) scale(0.8);
        opacity: 0.7;
    }
}

    </style>
</head>
<body>
    <!-- E-Reader Container -->
    <div class="ereader" id="ereader">
        <!-- Reading Area -->
        <div class="reading-area" id="reading-area">
            <!-- Page Container -->
            <div class="page-container" id="page-container">
                <!-- Pages will be dynamically added here -->
            </div>
            
            <!-- Touch Navigation Areas for Mobile -->
            <div class="touch-nav-area touch-nav-left" id="touch-nav-left"></div>
            <div class="touch-nav-area touch-nav-right" id="touch-nav-right"></div>
            
            <!-- Page Navigation Controls -->
            <div class="page-nav-controls" id="page-nav-controls">
                <button class="page-nav-button" id="prev-page-btn" disabled>&lt;</button>
                <button class="page-nav-button" id="next-page-btn">&gt;</button>
            </div>
        </div>
        
        <!-- Menu Button -->
        <button class="menu-button" id="menu-button">â˜°</button>
    </div>
    
    <!-- Menu Panel -->
    <div class="panel" id="menu-panel">
        <div class="panel-header">
            <h2>Menu</h2>
            <button class="close-panel-button" id="close-menu-btn">&times;</button>
        </div>
        <div class="menu-panel">
            <div class="font-size-control">
                <button id="decrease-font-btn">A-</button>
                <span class="font-size-label">Text Size</span>
                <button id="increase-font-btn">A+</button>
            </div>
            <ul class="menu-list">
                <li class="menu-item" id="go-to-cover-btn">Cover</li>
                <li class="menu-item" id="go-to-contents-btn">Table of Contents</li>
                <li class="menu-item" id="admin-page-link">Don't click here</li>
            </ul>
        </div>
    </div>
    
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="spinner"></div>
        <div class="loading-text">Loading your book...</div>
    </div>
    
    <script>
        /* === Global Variables === */
        // Book data structure
        let bookData = {
            title: 'My Serial E-Book',
            author: 'Your Name',
            coverImage: '',
            chapters: []
        };
        
        // Navigation state
        let currentPageIndex = 0;
        let totalPages = 0;
        let pagesMap = []; // Maps page indices to chapter/type info
        let chaptersLoaded = 0;
        let totalChaptersToLoad = 0;
        
        // Font size variables
        let currentFontSize = 90; // 90% is default
        const minFontSize = 70;    // 70% minimum
        const maxFontSize = 200;   // 200% maximum
        const fontSizeStep = 10;   // Change in 10% increments
        let forceRedraw = false;

       
        /* === Initialization === */
        document.addEventListener('DOMContentLoaded', function() {
            // Show loading screen
            showLoading();
            
            // Load book metadata
            loadBookMetadata()
                .then(() => {
                    // Initialize pages
                    return initializePages();
                })
                .then(() => {
                    // Setup event listeners
                    setupEventListeners();
                    
                    // Hide loading screen
                    hideLoading();
                })
                .catch(error => {
                    console.error('Error loading book:', error);
                    hideLoading();
                    alert('Error loading book data. Please try refreshing the page.');
                });
        });
        
        /* === Load Book Data === */
        // Load book metadata from book-meta.json
        async function loadBookMetadata() {
            try {
                const response = await fetch('data/book-meta.json');
                if (!response.ok) {
                    throw new Error(`Failed to load book metadata (${response.status})`);
                }
                
                const metadata = await response.json();
                bookData.title = metadata.title;
                bookData.author = metadata.author;
                bookData.coverImage = metadata.coverImage || '';
                
                // Load chapter list
                return loadChaptersList();
            } catch (error) {
                console.error('Error loading book metadata:', error);
                return Promise.reject(error);
            }
        }
        
        // Load list of chapters from chapters.json
        async function loadChaptersList() {
            try {
                const response = await fetch('data/chapters.json');
                if (!response.ok) {
                    throw new Error(`Failed to load chapters list (${response.status})`);
                }
                
                const chaptersData = await response.json();
                totalChaptersToLoad = chaptersData.length;
                
                // Load each chapter content
                const promises = chaptersData.map(chapterInfo => loadChapterContent(chapterInfo));
                
                return Promise.all(promises);
            } catch (error) {
                console.error('Error loading chapters list:', error);
                return Promise.reject(error);
            }
        }
        
        // Load individual chapter content
        async function loadChapterContent(chapterInfo) {
            try {
                const response = await fetch(`data/chapters/${chapterInfo.file}`);
                if (!response.ok) {
                    throw new Error(`Failed to load chapter ${chapterInfo.number} (${response.status})`);
                }
                
                const chapterData = await response.json();
                
                // Add chapter to book data
                bookData.chapters.push(chapterData);
                chaptersLoaded++;
                
                // Sort chapters by number
                bookData.chapters.sort((a, b) => a.number - b.number);
                
                return Promise.resolve();
            } catch (error) {
                console.error(`Error loading chapter ${chapterInfo.number}:`, error);
                return Promise.reject(error);
            }
        }
        
        /* === Setup Event Listeners === */
        function setupEventListeners() {
            // Page navigation buttons
            document.getElementById('prev-page-btn').addEventListener('click', goToPreviousPage);
            document.getElementById('next-page-btn').addEventListener('click', goToNextPage);
            
            // Touch/swipe for mobile
            setupSwipeNavigation();
            
            // Touch tap areas for mobile
            setupTapNavigation();
            
            // Menu button
            document.getElementById('menu-button').addEventListener('click', showMenuPanel);
            document.getElementById('close-menu-btn').addEventListener('click', hideMenuPanel);
            
            // Menu items
            document.getElementById('go-to-cover-btn').addEventListener('click', function() {
                goToPage(0);
                hideMenuPanel();
            });
            
            document.getElementById('go-to-contents-btn').addEventListener('click', function() {
                goToPage(2);
                hideMenuPanel();
            });
            
            document.getElementById('admin-page-link').addEventListener('click', function() {
                window.location.href = 'admin.html';
            });
            
            // Keyboard navigation
            document.addEventListener('keydown', function(e) {
                if (e.key === 'ArrowRight' || e.key === ' ') {
                    goToNextPage();
                } else if (e.key === 'ArrowLeft') {
                    goToPreviousPage();
                }
            });
            
            // Font size controls
            document.getElementById('increase-font-btn').addEventListener('click', function() {
                changeFontSize(fontSizeStep);
                hideMenuPanel();
            });
            
            document.getElementById('decrease-font-btn').addEventListener('click', function() {
                changeFontSize(-fontSizeStep);
                hideMenuPanel();
            });
        }

        // Handle orientation changes
window.addEventListener('orientationchange', function() {
    // Wait for the orientation change to complete
    setTimeout(function() {
        // Force regeneration of pages with optimal sizing for new orientation
        forceRedraw = true;
        changeFontSize(0); // Keep same font size but force redraw
        forceRedraw = false;
    }, 300);
});
        
        /* === Setup Tap Navigation for Mobile === */
        function setupTapNavigation() {
            // Left tap area for previous page
            const leftTapArea = document.getElementById('touch-nav-left');
            leftTapArea.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                goToPreviousPage();
            });
            
            // Right tap area for next page
            const rightTapArea = document.getElementById('touch-nav-right');
            rightTapArea.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                goToNextPage();
            });
            
            // Optional: Add middle tap area for menu access
            // This can help users access the menu from anywhere on the screen
            const pageContainer = document.getElementById('page-container');
            pageContainer.addEventListener('click', function(e) {
                // Only handle clicks in the middle area, not sides or interactive elements
                if (isInteractiveElement(e.target)) {
                    // Let the click proceed naturally for interactive elements
                    return true;
                }
                
                // Get click position relative to window width
                const clickX = e.clientX;
                const clickY = e.clientY;
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                
                // Calculate relative positions (0-1 range)
                const relativeX = clickX / windowWidth;
                const relativeY = clickY / windowHeight;
                
                // Only consider the middle horizontal area (between 25% and 75% of width)
                // AND only the top 20% of the screen height
                if (relativeX > 0.25 && relativeX < 0.75 && relativeY < 0.2) {
                    e.preventDefault();
                    
                    // Show menu when top-middle area is tapped
                    if (isMobileDevice()) {
                        showMenuPanel();
                    }
                }
            });
        }
        
        // Helper function to check if an element is an interactive element that should not trigger page turns
        function isInteractiveElement(element) {
            // Use native DOM methods to check if the click should be interactive
            let currentElement = element;
            
            while (currentElement) {
                // Check for links, buttons, inputs, and other interactive elements
                if (currentElement.tagName === 'A' || 
                    currentElement.tagName === 'BUTTON' ||
                    currentElement.tagName === 'INPUT' ||
                    currentElement.tagName === 'SELECT' ||
                    currentElement.tagName === 'TEXTAREA' ||
                    currentElement.classList.contains('footnote-ref') ||
                    currentElement.classList.contains('footnotes') ||
                    currentElement.classList.contains('footnote-item')) {
                    return true;
                }
                
                // Also check for elements with onclick attributes or event listeners
                if (currentElement.hasAttribute('onclick') || 
                    currentElement.getAttribute('role') === 'button') {
                    return true;
                }
                
                // Move up to parent element
                currentElement = currentElement.parentElement;
            }
            
            return false;
        }
        
        /* === Setup Swipe Navigation for Mobile === */
        function setupSwipeNavigation() {
            const pageContainer = document.getElementById('page-container');
            let touchStartX = 0;
            let touchEndX = 0;
            let isSwiping = false;
            let startTouches = null; // Store multiple touches to detect pinch
            
            pageContainer.addEventListener('touchstart', function(e) {
                // Don't initiate swipe if touching an interactive element
                if (isInteractiveElement(e.target)) {
                    isSwiping = false;
                    return;
                }
                
                // Store initial touches
                startTouches = e.touches;
                
                // If more than one touch point, it's a pinch gesture, don't initiate swipe
                if (startTouches.length > 1) {
                    isSwiping = false;
                    return;
                }
                
                // Check if page is currently scrolled - if so, don't initiate swipe
                const currentPage = document.querySelector('.page.active');
                if (currentPage && (currentPage.scrollTop > 0 || currentPage.scrollLeft > 0)) {
                    isSwiping = false;
                    return;
                }
                
                touchStartX = e.changedTouches[0].screenX;
                isSwiping = true;
            }, false);
            
            pageContainer.addEventListener('touchend', function(e) {
                // Skip if not swiping (e.g., if touching a link or pinching)
                if (!isSwiping) return;
                
                touchEndX = e.changedTouches[0].screenX;
                handleSwipe();
                isSwiping = false;
            }, false);
            
            function handleSwipe() {
                const swipeThreshold = 50;
                if (touchEndX < touchStartX - swipeThreshold) {
                    // Swipe left - go to next page
                    goToNextPage();
                }
                if (touchEndX > touchStartX + swipeThreshold) {
                    // Swipe right - go to previous page
                    goToPreviousPage();
                }
            }
        }
        
        /* === Page Initialization and Rendering === */
        // Initialize all pages
        function initializePages() {
            return new Promise((resolve) => {
                // Get saved font size preference before generating pages
                const savedFontSize = localStorage.getItem('ebook-font-size');
                if (savedFontSize) {
                    currentFontSize = parseInt(savedFontSize);
                }
                
                // Start with fresh pagination
                regeneratePages().then(() => {
                    // Show first page
                    if (totalPages > 0) {
                        showPage(0);
                    }
                    
                    resolve();
                });
            });
        }
        
        // Create the cover page with just the image
        function createCoverPage() {
            const pageContainer = document.getElementById('page-container');
            
            const coverPage = document.createElement('div');
            coverPage.className = 'page cover-page';
            coverPage.id = 'page-0';
            
            // Full-screen cover image only
            coverPage.innerHTML = `
                <div class="cover-image-container">
                    <img src="/Cover1.png" alt="${bookData.title} Cover" class="full-cover-image">
            <!-- Tap indicator component -->
            <div class="tap-indicator" id="tap-indicator">
                <!-- Ripple circles -->
                <div class="tap-circle tap-circle-1"></div>
                <div class="tap-circle tap-circle-2"></div>
                <div class="tap-circle tap-circle-3"></div>
                <!-- Center dot -->
                <div class="tap-center"></div>
                <!-- Arrow indicating swipe direction -->
                <div class="tap-arrow"></div>
            </div>                  
               </div>
            `;
            
            pageContainer.appendChild(coverPage);
            
            // Add to pages map
            pagesMap.push({ type: 'cover', index: 0 });
        }
        
// Create the dedication page with menu indicator
function createDedicationPage() {
    const pageContainer = document.getElementById('page-container');
    
    const dedicationPage = document.createElement('div');
    dedicationPage.className = 'page dedication-page';
    dedicationPage.id = 'page-1'; // This will become page 1
    
    dedicationPage.innerHTML = `
        <div class="dedication-content">
            <p class="dedication-top">And so am I.</p>
            <p class="dedication-bottom">For everyone, but especially you.</p>
            
            <!-- Menu indicator component -->
            <div class="menu-indicator" id="menu-indicator">
                <!-- Menu text (now above) -->
                <div class="menu-text">MENU</div>
                <!-- Ripple circles -->
                <div class="menu-circle menu-circle-1"></div>
                <div class="menu-circle menu-circle-2"></div>
                <div class="menu-circle menu-circle-3"></div>
                <!-- Center dot -->
                <div class="menu-center"></div>
            </div>
        </div>
    `;
    
    pageContainer.appendChild(dedicationPage);
    
    // Add to pages map
    pagesMap.push({ type: 'dedication', index: 0 });
}
        
        // Create the table of contents page
        function createTOCPage() {
            const pageContainer = document.getElementById('page-container');
            
            const tocPage = document.createElement('div');
            tocPage.className = 'page toc-page';
            tocPage.id = 'page-2';
            
            let tocContent = '<h1>Table of Contents</h1><ul class="toc-list">';
            
            for (let i = 0; i < bookData.chapters.length; i++) {
                const chapter = bookData.chapters[i];
                
                // For each chapter, we need to find its first page
                // We need to calculate this *after* all pages are created
                // So for now, we'll store the chapter index and update links later
                tocContent += `<li><span class="chapter-link" data-chapter-index="${i}">Chapter ${chapter.number}: ${chapter.title}</span>`;
                
                // Add "new" badge if chapter is less than 7 days old
                const publishDate = new Date(chapter.publishDate);
                const now = new Date();
                const daysDiff = Math.floor((now - publishDate) / (1000 * 60 * 60 * 24));
                
                if (daysDiff < 7) {
                    tocContent += '<span class="new-badge">NEW</span>';
                }
                
                tocContent += '</li>';
            }
            
            tocContent += '</ul>';
            
            tocPage.innerHTML = tocContent;
            pageContainer.appendChild(tocPage);
            
            // Add to pages map
            pagesMap.push({ type: 'toc', index: 0 });
        }
        
        // Update the TOC links after all pages are created
        function updateTOCLinks() {
            document.querySelectorAll('.chapter-link').forEach(link => {
                const chapterIndex = parseInt(link.getAttribute('data-chapter-index'));
                
                // Find the first page of this chapter
                const firstPageIndex = pagesMap.findIndex(p => 
                    p.type === 'chapter' && 
                    p.chapterIndex === chapterIndex && 
                    p.pageIndex === 0
                );
                
                if (firstPageIndex >= 0) {
                    // Set the data-page attribute with the correct page index
                    link.setAttribute('data-page', firstPageIndex);
                    
                    // Add click event listener
                    link.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        const pageNumber = parseInt(this.getAttribute('data-page'));
                        goToPage(pageNumber);
                    });
                }
            });
        }
        
        // Create pages for a chapter with improved footnote handling
   function createChapterPages(chapter, chapterIndex) {
    console.log('Creating chapter pages for:', chapter.title);
    
    if (!chapter.content) {
        console.error('No content found for chapter:', chapter.title);
        return;
    }
    
    // Use the height-based pagination system
    const pages = paginateContent(chapter.content, chapter.footnotes || [], {
        chapterNumber: chapter.number,
        chapterTitle: chapter.title
    });
    
    console.log(`Chapter "${chapter.title}" generated ${pages.length} pages`);
    
    // Create a page for each paginated content
    const pageContainer = document.getElementById('page-container');
    
    for (let i = 0; i < pages.length; i++) {
        const chapterPage = document.createElement('div');
        chapterPage.className = 'page chapter-page';
        chapterPage.id = `page-${pagesMap.length}`;
        
        // Add chapter title to first page of chapter only
        let titleHTML = '';
        if (i === 0) {
            titleHTML = `<h2>Chapter ${chapter.number}: ${chapter.title}</h2>`;
        }
        
        chapterPage.innerHTML = `
            ${titleHTML}
            <div class="page-content">${pages[i].content}</div>
            ${pages[i].footnotes ? `<div class="footnotes">${pages[i].footnotes}</div>` : ''}
        `;
        
        pageContainer.appendChild(chapterPage);
        
        // Add to pages map
        pagesMap.push({
            type: 'chapter',
            chapterIndex: chapterIndex,
            pageIndex: i,
            pageNumber: pagesMap.length
        });
        
        console.log(`Created chapter page ${i + 1}/${pages.length}, total pages now: ${pagesMap.length}`);
    }
}

        
        // Function to setup footnote references after pages are created
        function setupFootnoteReferences() {
            // Find all footnote references
            document.querySelectorAll('.footnote-ref').forEach(ref => {
                ref.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation(); // Stop the click from bubbling up to the tap areas
                    
                    // Get the footnote ID
                    const footnoteId = this.getAttribute('data-id');
                    
                    // Find the footnote
                    const footnote = document.getElementById(footnoteId);
                    
                    // If footnote exists, scroll to it
                    if (footnote) {
                        footnote.scrollIntoView({ behavior: 'smooth' });
                        
                        // Add a highlight effect
                        footnote.classList.add('footnote-highlight');
                        setTimeout(() => {
                            footnote.classList.remove('footnote-highlight');
                        }, 2000);
                    }
                });
            });
        }
        
        // Setup external links to prevent triggering page turns
        function setupExternalLinks() {
            // Find all links in footnotes
            document.querySelectorAll('.footnotes a').forEach(link => {
                link.addEventListener('click', function(e) {
                    e.stopPropagation(); // Stop the click from bubbling up to the tap areas
                    
                    // Optional: open in new tab
                    if (!this.getAttribute('target')) {
                        this.setAttribute('target', '_blank');
                        this.setAttribute('rel', 'noopener noreferrer');
                    }
                });
            });
        }
        
// ADD THESE MISSING FUNCTIONS TO YOUR CODE:

// 1. Extract footnote references from an element (this should have been kept from original code)
function extractFootnoteRefs(element) {
    const refs = [];
    const footnoteRegex = /<sup class="footnote-ref"[^>]*data-id="([^"]+)"[^>]*>.*?<\/sup>/g;
    const html = element.outerHTML || element.textContent;
    let match;
    
    while ((match = footnoteRegex.exec(html)) !== null) {
        refs.push(match[1]);
    }
    
    return refs;
}
        
// 2. Build footnotes HTML (this should also have been kept)
function buildFootnotesHTML(footnoteIds, footnotes) {
    if (!footnoteIds.length || !footnotes || !footnotes.length) {
        return '';
    }
    
    let html = '';
    
    // Get footnotes that are referenced on this page
    const pageFootnotes = footnotes.filter(fn => footnoteIds.includes(fn.id));
    
    if (pageFootnotes.length) {
        for (const footnote of pageFootnotes) {
            html += `<div id="${footnote.id}" class="footnote-item"><sup>${footnote.number}</sup> ${footnote.content}</div>`;
        }
    }
    
    return html;
}
        
        // Improved paginate content function that handles footnotes better
function paginateContent(content, footnotes, options) {
    console.log('Starting pagination with proper footnote height calculation...');
    console.log('Content length:', content.length);
    
    const pages = [];
    
    try {
        // Split content by paragraphs first
        const paragraphs = content.split('</p>').filter(p => p.trim());
        
        let currentPageContent = '';
        let currentPageFootnotes = new Set();
        
        // Create a temporary measurement container to test if content actually fits
        const measureContainer = createFootnoteMeasurementContainer();
        
        for (let i = 0; i < paragraphs.length; i++) {
            let paragraph = paragraphs[i];
            if (!paragraph.endsWith('</p>')) {
                paragraph += '</p>';
            }
            
            // Extract footnote references from this paragraph
            const footnoteRefs = extractFootnoteRefs({ outerHTML: paragraph });
            
            // Test if adding this paragraph would fit on the current page
            const testContent = currentPageContent + paragraph;
            const testFootnotes = new Set([...currentPageFootnotes, ...footnoteRefs]);
            
            if (doesContentAndFootnotesFit(measureContainer, testContent, testFootnotes, footnotes)) {
                // Content fits with footnotes, add to current page
                currentPageContent = testContent;
                footnoteRefs.forEach(ref => currentPageFootnotes.add(ref));
            } else {
                // Content doesn't fit, save current page and start new one
                if (currentPageContent.trim()) {
                    pages.push({
                        content: currentPageContent,
                        footnotes: buildFootnotesHTML(Array.from(currentPageFootnotes), footnotes)
                    });
                    console.log(`Created page ${pages.length} - content + footnotes fit properly`);
                }
                
                // Start new page with current paragraph
                currentPageContent = paragraph;
                currentPageFootnotes = new Set(footnoteRefs);
                
                // Check if even this single paragraph with its footnotes fits
                if (!doesContentAndFootnotesFit(measureContainer, currentPageContent, currentPageFootnotes, footnotes)) {
                    console.warn('Single paragraph with footnotes too large for page, may need splitting');
                    // For now, we'll put it on its own page anyway - could add paragraph splitting here
                }
            }
        }
        
        // Add the last page if it has content
        if (currentPageContent.trim()) {
            pages.push({
                content: currentPageContent,
                footnotes: buildFootnotesHTML(Array.from(currentPageFootnotes), footnotes)
            });
            console.log(`Created final page ${pages.length}`);
        }
        
        // Clean up measurement container
        if (measureContainer && measureContainer.parentNode) {
            document.body.removeChild(measureContainer);
        }
        
        console.log(`Generated ${pages.length} pages with proper footnote spacing`);
        
    } catch (error) {
        console.error('Error in paginateContent:', error);
        console.log('Falling back to simple character-based pagination...');
        
        // FALLBACK: Simple character-based pagination if measurement fails
        return fallbackPaginateContent(content, footnotes, options);
    }
    
    return pages;
}

// Create a measurement container that matches your real page layout
function createFootnoteMeasurementContainer() {
    console.log('Creating footnote measurement container...');
    
    // Try to find existing page elements
    let samplePage = document.querySelector('.page');
    let samplePageContent = document.querySelector('.page-content');
    
    // Default dimensions if no existing page found
    let pageWidth = window.innerWidth;
    let pageHeight = window.innerHeight;
    let pagePadding = '30px';
    let contentFontSize = '18px';
    let contentLineHeight = '1.7';
    let contentFontFamily = 'Georgia, serif';
    
    // If we have existing page elements, get their styles
    if (samplePage) {
        const pageStyles = window.getComputedStyle(samplePage);
        pageWidth = samplePage.offsetWidth;
        pageHeight = samplePage.offsetHeight;
        pagePadding = pageStyles.padding;
        
        if (samplePageContent) {
            const contentStyles = window.getComputedStyle(samplePageContent);
            contentFontSize = contentStyles.fontSize;
            contentLineHeight = contentStyles.lineHeight;
            contentFontFamily = contentStyles.fontFamily;
        }
        
        console.log('Using existing page styles for measurement');
    } else {
        console.log('No existing page found, using default dimensions');
        
        // Apply responsive padding based on screen size
        if (window.innerWidth <= 375) {
            pagePadding = '15px';
        } else if (window.innerWidth <= 480) {
            pagePadding = '20px';
        } else if (window.innerWidth <= 768) {
            pagePadding = '25px';
        }
        
        // Apply responsive font size
        if (window.innerWidth <= 768) {
            contentFontSize = '16px';
            contentLineHeight = '1.6';
        }
    }
    
    // Create measurement container with known good styles
    const measureContainer = document.createElement('div');
    measureContainer.className = 'page';
    measureContainer.style.position = 'absolute';
    measureContainer.style.visibility = 'hidden';
    measureContainer.style.top = '-9999px';
    measureContainer.style.left = '-9999px';
    measureContainer.style.width = pageWidth + 'px';
    measureContainer.style.height = pageHeight + 'px';
    measureContainer.style.padding = pagePadding;
    measureContainer.style.display = 'flex';
    measureContainer.style.flexDirection = 'column';
    measureContainer.style.overflow = 'hidden';
    measureContainer.style.backgroundColor = '#f4f0e8';
    measureContainer.style.fontFamily = contentFontFamily;
    
    // Add content area
    const contentArea = document.createElement('div');
    contentArea.className = 'page-content';
    contentArea.style.flex = '1';
    contentArea.style.overflow = 'hidden';
    contentArea.style.lineHeight = contentLineHeight;
    contentArea.style.fontSize = contentFontSize;
    contentArea.style.fontFamily = contentFontFamily;
    
    // Add footnotes area
    const footnotesArea = document.createElement('div');
    footnotesArea.className = 'footnotes';
    footnotesArea.style.borderTop = '1px solid #ccc';
    footnotesArea.style.marginTop = '20px';
    footnotesArea.style.paddingTop = '20px';
    footnotesArea.style.fontSize = '14px';
    footnotesArea.style.position = 'relative';
    footnotesArea.style.zIndex = '50';
    
    measureContainer.appendChild(contentArea);
    measureContainer.appendChild(footnotesArea);
    document.body.appendChild(measureContainer);
    
    console.log('Measurement container created successfully:', {
        width: pageWidth,
        height: pageHeight,
        padding: pagePadding,
        fontSize: contentFontSize
    });
    
    return measureContainer;
}

// FALLBACK pagination if measurement fails
function fallbackPaginateContent(content, footnotes, options) {
    console.log('Using fallback character-based pagination...');
    
    const pages = [];
    const paragraphs = content.split('</p>').filter(p => p.trim());
    
    let currentPageContent = '';
    let currentPageFootnotes = new Set();
    
    // Conservative character limit to account for footnotes
    const maxCharsPerPage = 1200; // Reduced to be safer with footnotes
    
    for (let i = 0; i < paragraphs.length; i++) {
        let paragraph = paragraphs[i];
        if (!paragraph.endsWith('</p>')) {
            paragraph += '</p>';
        }
        
        const footnoteRefs = extractFootnoteRefs({ outerHTML: paragraph });
        
        // Estimate footnote length
        let footnoteLength = 0;
        footnoteRefs.forEach(id => {
            const footnote = footnotes.find(fn => fn.id === id);
            if (footnote) {
                footnoteLength += footnote.content.length + 50; // Add overhead
            }
        });
        
        // Simple test with footnote consideration
        const totalLength = currentPageContent.length + paragraph.length + footnoteLength;
        
        if (totalLength > maxCharsPerPage && currentPageContent.length > 0) {
            // Save current page
            pages.push({
                content: currentPageContent,
                footnotes: buildFootnotesHTML(Array.from(currentPageFootnotes), footnotes)
            });
            
            // Start new page
            currentPageContent = paragraph;
            currentPageFootnotes = new Set(footnoteRefs);
        } else {
            // Add to current page
            currentPageContent += paragraph;
            footnoteRefs.forEach(ref => currentPageFootnotes.add(ref));
        }
    }
    
    // Add the last page
    if (currentPageContent.trim()) {
        pages.push({
            content: currentPageContent,
            footnotes: buildFootnotesHTML(Array.from(currentPageFootnotes), footnotes)
        });
    }
    
    console.log(`Fallback pagination generated ${pages.length} pages`);
    return pages;
}

// Test if content and footnotes actually fit on a page
function doesContentAndFootnotesFit(measureContainer, content, footnoteIds, allFootnotes) {
    try {
        const contentArea = measureContainer.querySelector('.page-content');
        const footnotesArea = measureContainer.querySelector('.footnotes');
        
        if (!contentArea || !footnotesArea) {
            console.warn('Measurement container missing required elements');
            return false;
        }
        
        // Set the content
        contentArea.innerHTML = content;
        
        // Set the footnotes
        const footnotesHTML = buildFootnotesHTML(Array.from(footnoteIds), allFootnotes);
        footnotesArea.innerHTML = footnotesHTML;
        
        // Force a reflow to get accurate measurements
        measureContainer.offsetHeight;
        
        // Get the actual heights
        const contentHeight = contentArea.scrollHeight;
        const footnotesHeight = footnotesArea.scrollHeight;
        const containerHeight = measureContainer.clientHeight;
        
        // Calculate padding
        const computedStyle = window.getComputedStyle(measureContainer);
        const containerPadding = parseInt(computedStyle.paddingTop) + parseInt(computedStyle.paddingBottom);
        
        // Available height
        const availableHeight = containerHeight - containerPadding;
        
        // Account for footnotes margin and border
        const footnotesMarginAndBorder = footnotesHTML ? 40 : 0;
        
        // Total used height
        const totalUsedHeight = contentHeight + footnotesHeight + footnotesMarginAndBorder;
        
        // Safety margin
        const safetyMargin = 30; // Increased safety margin
        const fits = totalUsedHeight + safetyMargin <= availableHeight;
        
        if (!fits) {
            console.log('Content overflow detected:', {
                contentHeight,
                footnotesHeight,
                totalUsed: totalUsedHeight,
                available: availableHeight,
                safetyMargin,
                overflow: totalUsedHeight + safetyMargin - availableHeight
            });
        }
        
        return fits;
        
    } catch (error) {
        console.error('Error in doesContentAndFootnotesFit:', error);
        return false; // If measurement fails, assume it doesn't fit
    }
}
        
// Create a hidden measurement container that matches the real page styling
function createMeasurementContainer() {
    // Find an existing page to copy dimensions from
    let samplePage = document.querySelector('.page-content');
    let parentPage = document.querySelector('.page');
    
    // If no existing page, create a temporary reference
    if (!samplePage || !parentPage) {
        parentPage = createTemporaryPageReference();
        samplePage = parentPage.querySelector('.page-content');
    }
    
    // Get computed styles from the sample page
    const sampleStyles = window.getComputedStyle(samplePage);
    const parentStyles = window.getComputedStyle(parentPage);
    
    // Calculate available space for content
    const parentHeight = parentPage.clientHeight;
    const parentPadding = parseInt(parentStyles.paddingTop) + parseInt(parentStyles.paddingBottom);
    
    // Account for chapter title space (if this is the first page of a chapter)
    const chapterTitleHeight = 70; // Approximate height of chapter title
    const footnotesBorderHeight = 20; // Space for footnotes border/margin
    
    // Maximum height for content only (excluding footnotes)
    const maxContentHeight = parentHeight - parentPadding - chapterTitleHeight - footnotesBorderHeight;
    
    // Total available height including footnotes
    const maxHeight = parentHeight - parentPadding;
    
    // Create measurement container
    const measureDiv = document.createElement('div');
    measureDiv.className = parentPage.className;
    measureDiv.style.position = 'absolute';
    measureDiv.style.visibility = 'hidden';
    measureDiv.style.top = '-9999px';
    measureDiv.style.left = '-9999px';
    measureDiv.style.width = parentPage.offsetWidth + 'px';
    measureDiv.style.height = 'auto';
    measureDiv.style.padding = parentStyles.padding;
    measureDiv.style.margin = parentStyles.margin;
    measureDiv.style.fontFamily = parentStyles.fontFamily;
    measureDiv.style.fontSize = parentStyles.fontSize;
    measureDiv.style.lineHeight = parentStyles.lineHeight;
    measureDiv.style.overflow = 'visible';
    
    // Add the same structure as a real page
    measureDiv.innerHTML = `
        <div class="page-content" style="
            font-size: ${sampleStyles.fontSize};
            line-height: ${sampleStyles.lineHeight};
            flex: 1;
            overflow: visible;
        "></div>
        <div class="footnotes-container"></div>
    `;
    
    document.body.appendChild(measureDiv);
    
    return { measureDiv, maxHeight, maxContentHeight };
}

// Create a temporary page reference for measurement if none exists
function createTemporaryPageReference() {
    const tempPage = document.createElement('div');
    tempPage.className = 'page';
    tempPage.style.position = 'absolute';
    tempPage.style.visibility = 'hidden';
    tempPage.style.top = '-9999px';
    tempPage.style.left = '-9999px';
    tempPage.style.width = '100vw';
    tempPage.style.height = '100vh';
    tempPage.style.padding = '30px';
    
    // Apply current font size
    const currentFontSize = parseInt(localStorage.getItem('ebook-font-size')) || 100;
    
    tempPage.innerHTML = `
        <div class="page-content" style="
            flex: 1;
            overflow: hidden;
            line-height: 1.7;
            font-size: ${currentFontSize}%;
        "></div>
    `;
    
    document.body.appendChild(tempPage);
    return tempPage;
}

// Test if content fits on a page by measuring actual height
function testContentFitsOnPage(measureDiv, content, footnoteIds, allFootnotes, maxContentHeight) {
    const contentContainer = measureDiv.querySelector('.page-content');
    const footnotesContainer = measureDiv.querySelector('.footnotes-container');
    
    // Set the content
    contentContainer.innerHTML = content;
    
    // Set the footnotes
    const footnotesHTML = buildFootnotesHTML(Array.from(footnoteIds), allFootnotes);
    footnotesContainer.innerHTML = footnotesHTML;
    
    // Force a reflow to get accurate measurements
    measureDiv.offsetHeight;
    
    // Get heights
    const contentHeight = contentContainer.scrollHeight;
    const footnotesHeight = footnotesContainer.scrollHeight;
    const totalHeight = contentHeight + footnotesHeight;
    
    // Content fits if total height is within limits
    // Also ensure content alone doesn't exceed the content-only limit
    return totalHeight <= measureDiv.clientHeight && contentHeight <= maxContentHeight;
}

// Split an element that's too large for a single page
function splitElementByHeight(element, footnoteRefs, allFootnotes, measureDiv, maxContentHeight) {
    const pages = [];
    
    // If it's not a paragraph, we can't split it - just put it on its own page
    if (element.tagName !== 'P') {
        const elementHTML = element.outerHTML || element.textContent;
        return [{
            content: elementHTML,
            footnotes: buildFootnotesHTML(footnoteRefs, allFootnotes),
            footnoteIds: footnoteRefs
        }];
    }
    
    // For paragraphs, split by sentences or words
    const text = element.textContent;
    const elementTag = element.tagName.toLowerCase();
    const elementAttributes = getElementAttributes(element);
    
    // Try splitting by sentences first
    const sentences = text.match(/[^\.!?]+[\.!?]+/g) || [text];
    
    let currentPageText = '';
    
    for (let i = 0; i < sentences.length; i++) {
        const sentence = sentences[i];
        const testText = currentPageText + sentence;
        const testHTML = `<${elementTag}${elementAttributes}>${testText}</${elementTag}>`;
        
        // For simplicity, assign all footnotes to the first part
        // In a more sophisticated implementation, you'd track which footnotes belong to which part
        const pageFootnotes = i === 0 ? footnoteRefs : [];
        
        if (testContentFitsOnPage(measureDiv, testHTML, new Set(pageFootnotes), allFootnotes, maxContentHeight)) {
            currentPageText = testText;
        } else {
            // Current sentence doesn't fit
            if (currentPageText.trim()) {
                // Save current page
                const pageHTML = `<${elementTag}${elementAttributes}>${currentPageText}</${elementTag}>`;
                pages.push({
                    content: pageHTML,
                    footnotes: buildFootnotesHTML(pageFootnotes, allFootnotes),
                    footnoteIds: pageFootnotes
                });
            }
            
            // Start new page with current sentence
            currentPageText = sentence;
            
            // If even a single sentence doesn't fit, split by words
            const singleSentenceHTML = `<${elementTag}${elementAttributes}>${sentence}</${elementTag}>`;
            if (!testContentFitsOnPage(measureDiv, singleSentenceHTML, new Set(), allFootnotes, maxContentHeight)) {
                // Split this sentence by words
                const wordSplitResult = splitByWords(sentence, elementTag, elementAttributes, measureDiv, maxContentHeight, allFootnotes);
                pages.push(...wordSplitResult);
                currentPageText = '';
            }
        }
    }
    
    // Add remaining text as final page
    if (currentPageText.trim()) {
        const finalHTML = `<${elementTag}${elementAttributes}>${currentPageText}</${elementTag}>`;
        pages.push({
            content: finalHTML,
            footnotes: buildFootnotesHTML([], allFootnotes),
            footnoteIds: []
        });
    }
    
    return pages;
}

// Split text by words when even sentences are too long
function splitByWords(text, tagName, attributes, measureDiv, maxContentHeight, allFootnotes) {
    const words = text.split(' ');
    const pages = [];
    let currentText = '';
    
    for (const word of words) {
        const testText = currentText ? `${currentText} ${word}` : word;
        const testHTML = `<${tagName}${attributes}>${testText}</${tagName}>`;
        
        if (testContentFitsOnPage(measureDiv, testHTML, new Set(), allFootnotes, maxContentHeight)) {
            currentText = testText;
        } else {
            if (currentText.trim()) {
                pages.push({
                    content: `<${tagName}${attributes}>${currentText}</${tagName}>`,
                    footnotes: '',
                    footnoteIds: []
                });
            }
            currentText = word;
        }
    }
    
    if (currentText.trim()) {
        pages.push({
            content: `<${tagName}${attributes}>${currentText}</${tagName}>`,
            footnotes: '',
            footnoteIds: []
        });
    }
    
    return pages;
}

// Get element attributes as a string
function getElementAttributes(element) {
    let attributes = '';
    for (const attr of element.attributes) {
        attributes += ` ${attr.name}="${attr.value}"`;
    }
    return attributes;
}
           
        
        // Build footnotes HTML
function buildFootnotesHTML(footnoteIds, footnotes) {
    if (!footnoteIds.length || !footnotes || !footnotes.length) {
        return '';
    }
    
    let html = '';
    
    // Get footnotes that are referenced on this page
    const pageFootnotes = footnotes.filter(fn => footnoteIds.includes(fn.id));
    
    if (pageFootnotes.length) {
        for (const footnote of pageFootnotes) {
            html += `<div id="${footnote.id}" class="footnote-item"><sup>${footnote.number}</sup> ${footnote.content}</div>`;
        }
    }
    
    return html;
}

        
        /* === Page Navigation === */
        // Show a specific page
        function showPage(pageIndex) {
            if (pageIndex < 0 || pageIndex >= pagesMap.length) {
                return false;
            }
            
            // Get all pages
            const pages = document.querySelectorAll('.page');
            
            // Reset all pages
            pages.forEach(page => {
                page.classList.remove('active', 'previous', 'next');
                page.style.transform = '';
            });
            
            // Get current, previous and next pages
            const currentPage = document.getElementById(`page-${pageIndex}`);
            const prevPage = pageIndex > 0 ? document.getElementById(`page-${pageIndex - 1}`) : null;
            const nextPage = pageIndex < pagesMap.length - 1 ? document.getElementById(`page-${pageIndex + 1}`) : null;
            
            // Set classes for animation
            if (currentPage) {
                currentPage.classList.add('active');
                
                // Reset scroll position to top when changing pages
                if (currentPage.scrollTo) {
                    currentPage.scrollTo(0, 0);
                }
            }
            
            if (prevPage) {
                prevPage.classList.add('previous');
            }
            
            if (nextPage) {
                nextPage.classList.add('next');
            }
            
            // Update current page index
            currentPageIndex = pageIndex;
            
            // Update navigation
            updateNavigation();
            
            return true;
        }
        
        // Go to previous page
        function goToPreviousPage() {
            if (currentPageIndex > 0) {
                showPage(currentPageIndex - 1);
            }
        }
        
        // Go to next page
        function goToNextPage() {
            if (currentPageIndex < pagesMap.length - 1) {
                showPage(currentPageIndex + 1);
            }
        }
        
        // Go to a specific page
        function goToPage(pageIndex) {
            showPage(pageIndex);
        }
        
        // Update navigation buttons state
        function updateNavigation() {
            const prevBtn = document.getElementById('prev-page-btn');
            const nextBtn = document.getElementById('next-page-btn');
            
            prevBtn.disabled = currentPageIndex <= 0;
            nextBtn.disabled = currentPageIndex >= pagesMap.length - 1;
        }
        
        /* === Menu Panel Functions === */
        // Show menu panel
        function showMenuPanel() {
            document.getElementById('menu-panel').classList.add('active');
        }
        
        // Hide menu panel
        function hideMenuPanel() {
            document.getElementById('menu-panel').classList.remove('active');
        }
        
        /* === Utility Functions === */
        // Show loading overlay
        function showLoading() {
            document.getElementById('loading-overlay').style.display = 'flex';
        }
        
        // Hide loading overlay
        function hideLoading() {
            document.getElementById('loading-overlay').style.display = 'none';
        }
        
        // Check if device is mobile
        function isMobileDevice() {
            return window.innerWidth <= 768;
        }
        
        // Add mobile-specific features if on mobile device
        function setupMobileFeatures() {
            if (isMobileDevice()) {
                // Make sure tap areas are visible
                document.getElementById('touch-nav-left').style.display = 'block';
                document.getElementById('touch-nav-right').style.display = 'block';
                
                // Hide navigation buttons
                document.getElementById('page-nav-controls').style.display = 'none';
                
                // Add a mobile class to the body for additional styling
                document.body.classList.add('mobile-device');
            } else {
                // Show navigation buttons on desktop
                document.getElementById('page-nav-controls').style.display = 'flex';
                
                // Hide tap areas on desktop
                document.getElementById('touch-nav-left').style.display = 'none';
                document.getElementById('touch-nav-right').style.display = 'none';
                
                // Remove mobile class if exists
                document.body.classList.remove('mobile-device');
            }
        }
        
        // Update mobile features when window resizes
        window.addEventListener('resize', function() {
            setupMobileFeatures();
        });
        
        // Function to change the font size
        function changeFontSize(delta) {
            // Only proceed if there's actually a change
            if (delta === 0 && !forceRedraw) return;
            
            // Show loading overlay while we repaginate
            showLoading();
            
            // Update current font size with bounds checking
            currentFontSize = Math.max(minFontSize, Math.min(maxFontSize, currentFontSize + delta));
            
            // Save preference to localStorage for persistence
            localStorage.setItem('ebook-font-size', currentFontSize);
            
            // Remember which chapter and position we're currently viewing
            const currentPage = pagesMap[currentPageIndex];
            
            // Completely regenerate all pages with the new font size
            regeneratePages().then(() => {
                // After regeneration, try to go back to approximately where we were reading
                if (currentPage) {
                    let newPageIndex = 0;
                    
                    if (currentPage.type === 'chapter') {
                        // Find the first page of the same chapter
                        newPageIndex = pagesMap.findIndex(p => 
                            p.type === 'chapter' && 
                            p.chapterIndex === currentPage.chapterIndex
                        );
                        
                        if (newPageIndex < 0) newPageIndex = 0;
                    } else {
                        // For non-chapter pages (cover, dedication, TOC), go to the same type
                        newPageIndex = pagesMap.findIndex(p => p.type === currentPage.type);
                        if (newPageIndex < 0) newPageIndex = 0;
                    }
                    
                    // Go to that page
                    showPage(newPageIndex);
                }
                
                // Hide loading overlay
                hideLoading();
            });
        }
        
        // Function to regenerate all pages
      async function regeneratePages() {
    console.log('=== STARTING PAGE REGENERATION ===');
    console.time('Page generation');
    showLoading();
    
    // Clear page container
    const pageContainer = document.getElementById('page-container');
    pageContainer.innerHTML = '';
    
    // Reset page mapping but keep the chapter data
    pagesMap = [];
    
    console.log('Creating special pages...');
    
    // Create cover page (page 0)
    createCoverPage();
    console.log('Cover page created, pagesMap length:', pagesMap.length);
    
    // Create dedication page (page 1)
    createDedicationPage();
    console.log('Dedication page created, pagesMap length:', pagesMap.length);
    
    // Create TOC page (now page 2)
    createTOCPage();
    console.log('TOC page created, pagesMap length:', pagesMap.length);
    
    console.log('Book data chapters:', bookData.chapters.length);
    
    try {
        // Process each chapter with height-based pagination
        for (let i = 0; i < bookData.chapters.length; i++) {
            console.log(`\n=== Processing Chapter ${i + 1} ===`);
            console.log('Chapter data:', {
                number: bookData.chapters[i].number,
                title: bookData.chapters[i].title,
                contentLength: bookData.chapters[i].content ? bookData.chapters[i].content.length : 0,
                footnotes: bookData.chapters[i].footnotes ? bookData.chapters[i].footnotes.length : 0
            });
            
            const chapterPagesBefore = pagesMap.length;
            createChapterPages(bookData.chapters[i], i);
            const chapterPagesAfter = pagesMap.length;
            
            console.log(`Chapter ${i + 1} created ${chapterPagesAfter - chapterPagesBefore} pages`);
            
            // Yield to UI thread if there are many chapters
            if (bookData.chapters.length > 5 && i % 2 === 1) {
                await new Promise(resolve => setTimeout(resolve, 0));
            }
        }
        
        // Update total pages
        totalPages = pagesMap.length;
        console.log('Total pages created:', totalPages);
        console.log('Pages map preview:', pagesMap.slice(0, 10)); // Show first 10 pages
        
        // Setup TOC links and other features
        updateTOCLinks();
        setupFootnoteReferences();
        setupExternalLinks();
        
        // Apply current font size to all content
        document.querySelectorAll('.page-content').forEach(content => {
            content.style.fontSize = `${currentFontSize}%`;
        });
        
        document.querySelectorAll('.footnotes').forEach(footnotes => {
            footnotes.style.fontSize = `${Math.floor(currentFontSize * 0.8)}%`;
        });
        
        // Update navigation buttons
        updateNavigation();
        
        // Initialize mobile features
        setupMobileFeatures();
        
        // REMOVED: monitorTextOverflow call (not needed with height-based pagination)
        
    } catch (error) {
        console.error('Error during page generation:', error);
        console.error('Error stack:', error.stack);
        
        // Add fallback content if there's an error
        if (pagesMap.length <= 3) { // Only cover, dedication, and TOC
            console.log('Adding fallback error page...');
            const errorPage = document.createElement('div');
            errorPage.className = 'page';
            errorPage.id = `page-${pagesMap.length}`;
            errorPage.innerHTML = `
                <div class="page-content">
                    <h2>Error Loading Content</h2>
                    <p>There was an error generating book pages. Please try refreshing the page.</p>
                    <p>Error details: ${error.message}</p>
                    <p>Check the browser console for more details.</p>
                </div>
            `;
            pageContainer.appendChild(errorPage);
            pagesMap.push({ type: 'error', index: 0 });
            totalPages = pagesMap.length;
        }
    }
    
    console.timeEnd('Page generation');
    console.log('=== PAGE REGENERATION COMPLETE ===');
    console.log('Final total pages:', totalPages);
    console.log('Can navigate to chapter?', totalPages > 3);
    hideLoading();
    
    return Promise.resolve();
}
        
        // Load saved font size preference
        function loadUserPreferences() {
            // Get saved font size (if any)
            const savedFontSize = localStorage.getItem('ebook-font-size');
            if (savedFontSize) {
                currentFontSize = parseInt(savedFontSize);
                
                // Apply font size directly to elements without repagination
                document.querySelectorAll('.page-content').forEach(content => {
                    content.style.fontSize = `${currentFontSize}%`;
                });
                
                document.querySelectorAll('.footnotes').forEach(footnotes => {
                    footnotes.style.fontSize = `${currentFontSize * 0.8}%`;
                });
            }
        }
        
// Function to show the tap indicator only on the first visit to the site
function showTapIndicator() {
    // Check if this is the first visit
    const hasVisited = localStorage.getItem('has_visited_site');
    
    if (!hasVisited || hasVisited !== 'true') {
        // Show the tap indicator
        const tapIndicator = document.getElementById('tap-indicator');
        if (tapIndicator) {
            tapIndicator.style.display = 'block';
            
            // Hide the indicator after animation completes (8 seconds)
            setTimeout(() => {
                tapIndicator.style.display = 'none';
            }, 8000);
        }
        
        // Set the flag that user has visited the site
        localStorage.setItem('has_visited_site', 'true');
    }
}

// Function to show the menu indicator on page 2 (dedication page)
function showMenuIndicator() {
    // Check if this is the first time seeing page 2
    const hasSeenPage2 = localStorage.getItem('has_seen_page_2');
    
    if (!hasSeenPage2 || hasSeenPage2 !== 'true') {
        // Show the menu indicator
        const menuIndicator = document.getElementById('menu-indicator');
        if (menuIndicator) {
            menuIndicator.style.display = 'block';
            
            // Hide the indicator after animation completes (8 seconds)
            setTimeout(() => {
                menuIndicator.style.display = 'none';
            }, 8000);
        }
        
        // Set the flag that user has seen page 2
        localStorage.setItem('has_seen_page_2', 'true');
    }
}

// Override the existing showPage function
const originalShowPage = showPage;
showPage = function(pageIndex) {
    const result = originalShowPage(pageIndex);
    
    // If we're showing the cover page (index 0) and it's the first load
    if (pageIndex === 0 && !document.hasShownTapIndicator) {
        showTapIndicator();
        document.hasShownTapIndicator = true;
    }
    
    // If we're showing the dedication page (index 1)
    if (pageIndex === 1) {
        showMenuIndicator();
    }
    
    return result;
}; 

function monitorTextOverflow() {
    // No longer needed with height-based pagination
    console.log('monitorTextOverflow called (stub function)');
}

function detectTextOverflow() {
    return false; // Stub function
}

// Debug function to check footnote sizes
function debugFootnoteSizes() {
    console.log('=== DEBUGGING FOOTNOTE SIZES ===');
    
    const activePage = document.querySelector('.page.active');
    if (activePage) {
        const contentArea = activePage.querySelector('.page-content');
        const footnotesArea = activePage.querySelector('.footnotes');
        
        if (contentArea && footnotesArea) {
            const contentHeight = contentArea.scrollHeight;
            const footnotesHeight = footnotesArea.scrollHeight;
            const pageHeight = activePage.clientHeight;
            
            console.log('Page dimensions:', {
                pageHeight,
                contentHeight,
                footnotesHeight,
                totalContent: contentHeight + footnotesHeight,
                remaining: pageHeight - (contentHeight + footnotesHeight),
                isOverflowing: (contentHeight + footnotesHeight) > pageHeight
            });
            
            // Check individual footnotes
            const footnoteItems = footnotesArea.querySelectorAll('.footnote-item');
            footnoteItems.forEach((footnote, index) => {
                console.log(`Footnote ${index + 1}:`, {
                    height: footnote.offsetHeight,
                    content: footnote.textContent.substring(0, 50) + '...'
                });
            });
        }
    }
}

// Call this to debug footnote issues: debugFootnoteSizes()

// Test function to verify footnote measurement is working
function testFootnoteMeasurement() {
    console.log('=== TESTING FOOTNOTE MEASUREMENT ===');
    
    const testContainer = createFootnoteMeasurementContainer();
    
    // Test with different content sizes
    const testCases = [
        { content: '<p>Short content</p>', footnotes: [] },
        { content: '<p>Medium length content that takes up more space and might have footnotes</p>', footnotes: ['footnote1'] },
        { content: '<p>Very long content that definitely should not fit with large footnotes and should trigger a page break when combined with substantial footnote content</p>', footnotes: ['footnote1', 'footnote2'] }
    ];
    
    // Mock footnotes for testing
    const mockFootnotes = [
        { id: 'footnote1', number: 1, content: 'This is a short footnote.' },
        { id: 'footnote2', number: 2, content: 'This is a much longer footnote that contains substantial additional information and might cause overflow issues if not properly accounted for in the pagination system.' }
    ];
    
    testCases.forEach((testCase, index) => {
        const fits = doesContentAndFootnotesFit(testContainer, testCase.content, new Set(testCase.footnotes), mockFootnotes);
        console.log(`Test case ${index + 1}: ${fits ? 'FITS' : 'DOES NOT FIT'}`);
    });
    
    document.body.removeChild(testContainer);
    console.log('Footnote measurement test complete');
}

// Call this to test: testFootnoteMeasurement()
        
    </script>
</body>
</html>
